ifndef::leveloffset[]
:toc: left
:toclevels: 3
:icons: font
endif::[]

include::header.adoc[]

== PowerShell examples

=== Scripting

==== Version

[source,powershell]
----
$PSVersionTable
----

==== Get script location

.How can I get the file system location of a PowerShell script?
The path of a running scripts is::
$PSCommandPath

Its directory is::
$PSScriptRoot

==== Modules

* Load functions
+
[source,powershell]
----
. (Join-Path -Path $PSScriptRoot -ChildPath 'Get-Factorial')

Get-Factorial($Args[0])
----

==== Environment Variables

.References
* https://adamtheautomator.com/powershell-environment-variables/[PowerShell and Environment Variables: A Deep Dive^] +
powershell remove env - Google 検索

.List environment variables
* List environment variables
+
[source,powershell]
----
dir env:
----

* Split path
+
[source,powershell]
----
$Env:PATH.split(';')
----

=== Array

[source,ps1con]
.Array to TSV
----
PS> @('AAA', 'BBB', 'CCC') -join "`t"
AAA     BBB     CCC
----

=== String

==== Encoding

[source,powershell]
----
[Text.Encoding]::UTF8
[System.Text.Encoding]::GetEncoding('shift_jis')
----

==== Combines multiple strings

* Using `+`
+
[source,powershell]
----
"abc" + "123" + "cdf"
----
+
[source,plaintext]
.Result
----
abc123cdf
----

* Using Join
+
[source,powershell]
----
"abc", "123", "cdf" -join ""
----
+
[source,plaintext]
.Result
----
abc123cdf
----

* Using concat
+
[source,powershell]
----
[System.String]::Concat("abc", "123", "cdf")
----
+
[source,plaintext]
.Result
----
abc123cdf
----

.References
* https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_join?view=powershell-7.2[about Join - PowerShell | Microsoft Docs^]
* https://docs.microsoft.com/en-us/dotnet/api/system.string?view=net-6.0[String Class (System) | Microsoft Docs^]

==== encoding base64

* encode base64
+
[source,powershell]
.ASCII.GetBytes
----
$someString = "abcdefghijklmnopqrstuvwxyz012345"
[System.Convert]::ToBase64String([System.Text.Encoding]::ASCII.GetBytes($someString))
----
+
[source,powershell]
.UTF8.GetBytes
----
$someString = "abcdefghijklmnopqrstuvwxyz012345"
[System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($someString))
----
+
----
YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU=
----
+
[source,powershell]
.decode base64
----
$someStringAsBase64 = "YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU="
[System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String($someStringAsBase64))
----

* encode base64
+
[source,powershell]
----
$someString = "こんにちは世界"
[System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($someString))
----
+
----
44GT44KT44Gr44Gh44Gv5LiW55WM
----
+
[source,powershell]
----
$someStringAsBase64 = "44GT44KT44Gr44Gh44Gv5LiW55WM"
[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($someStringAsBase64))
----
+
----
こんにちは世界
----

.Reference
* https://stackoverflow.com/questions/15414678/how-to-decode-a-base64-string[powershell - How to decode a Base64 string? - Stack Overflow^]

==== Generate passwords

[source,powershell]
----
Add-Type -AssemblyName System.web
1..10 | %{ [System.web.security.membership]::GeneratePassword(12, 0) } | Sort-Object
----

==== MD5

* using ComputeHash
+
[source,powershell]
----
$someString = "abcdefghijklmnopqrstuvwxyz012345"
$md5 = [System.Security.Cryptography.MD5]::Create()
[System.Convert]::ToBase64String($md5.ComputeHash([System.Text.Encoding]::UTF8.GetBytes($someString)))
$md5.Dispose()
----

* using ComputeHash (deprecated)
+
[source,powershell]
----
$someString = "abcdefghijklmnopqrstuvwxyz012345"
$md5 = New-Object -TypeName System.Security.Cryptography.MD5CryptoServiceProvider
[System.Convert]::ToBase64String($md5.ComputeHash([System.Text.Encoding]::UTF8.GetBytes($someString)))
$md5.Dispose()
----

* using Get-FileHash
+
[source,powershell]
----
$someString = "abcdefghijklmnopqrstuvwxyz012345"
$stream = [IO.MemoryStream]::new([Text.Encoding]::UTF8.GetBytes($someString))
$hash = Get-FileHash -InputStream $stream -Algorithm MD5
[System.Convert]::ToBase64String(($hash.Hash -split '([A-F0-9]{2})' | ForEach-Object { if($_) { [System.Convert]::ToByte($_, 16) } }))
$stream.Close()
----

.Results
----
NX6C25NPxF9KJbS4Pci9GQ==
----

=== Flow control statements

* Loop using range
+
[source,powershell]
----
1..5
----
+
[source,powershell]
.ForEach-Object
----
1..5 | % { Write-Output $_ }
----
+
[source,powershell]
.ForEach-Object
----
1..5 | ForEach-Object { Write-Output $_ }
----
+
[source,powershell]
----
foreach($i in 1..5) {
  Write-Output $i
}
----

** Results
+
[source,plaintext]
.Results
----
1
2
3
4
5
----

* Loop using counter
+
[source,powershell]
----
for($i=1; $i -le 5; $i++) {
  Write-Output $i
}
----

** Results
+
[source,plaintext]
.Results
----
1
2
3
4
5
----

* loop with condition
+
[source,powershell]
----
$i = 1
while ($i -le 5) {
  Write-Output $i
  $i += 1
}
----
+
[source,powershell]
----
$i = 1
do {
  Write-Output $i
  $i += 1
} while ($i -le 5)
----

=== External command

* https://adamtheautomator.com/powershell-exit/[How to Use the PowerShell Exit Command and Friends^] +
  powershell exit terminal - Google 検索

==== Get full path to binary in powershell

Equivalent of cmd's "where" in powershell

[source,powershell]
----
Get-Command command_name
gcm command_name
----

.Examples
* show `Path` attribute
+
[source,console]
----
> gcm python | % Path
C:\PythonNNN\python.exe
> (gcm python).Path
C:\PythonNNN\python.exe
----
+
[source,console]
----
> Get-Command -Name python | ForEach-Object Path
C:\PythonNNN\python.exe
> Get-Command -Name python | % Path
C:\PythonNNN\python.exe
> Get-Command -Name python | Select-Object -ExpandProperty Path
C:\PythonNNN\python.exe
> Get-Command -Name python | select -ExpandProperty Path
C:\PythonNNN\python.exe
----
+
[source,console,subs="attributes+"]
--------
> Get-Command -Name python | Select-Object -Property Path

Path
----
C:\PythonNNN\python.exe
--------

* Format-List
+
[source,console]
----
> gcm python | fl


Name            : python.exe
CommandType     : Application
Definition      : C:\PythonNNN\python.exe
Extension       : .exe
Path            : C:\PythonNNN\python.exe
FileVersionInfo : File:             C:\PythonNNN\python.exe
                  InternalName:     Python Console
                  OriginalFilename: python.exe
                  FileVersion:      3.MM.P
                  FileDescription:  Python
                  Product:          Python
                  ProductVersion:   3.MM.P
                  Debug:            False
                  Patched:          False
                  PreRelease:       False
                  PrivateBuild:     False
                  SpecialBuild:     False
                  Language:         ニュートラル言語
----

==== Execute command

[source,powershell]
----
  $process = Start-Process -FilePath ffmpeg.exe -ArgumentList "-i",$_.Name,"-vcodec","copy","-acodec","libopus",$_.Name.Replace('Vorbis', 'Opus') -NoNewWindow -PassThru -Wait
  $process.ExitCode
----

[source,powershell]
----
  $pInfo = New-Object System.Diagnostics.Process
  $pInfo.StartInfo.FileName = "...\ffmpeg.exe"
  $arguments = "-y -i `"$($_.Name)`" -vcodec copy -acodec libopus `"$($_.Name.Replace('Vorbis', 'Opus'))`""
  $pInfo.StartInfo.Arguments = $arguments
  Write-Host $arguments
  $pInfo.StartInfo.UseShellExecute = $false
  $pInfo.StartInfo.CreateNoWindow = $true
  $pInfo.StartInfo.RedirectStandardOutput = $true
  $pInfo.StartInfo.StandardOutputEncoding = [Text.Encoding]::UTF8
  $pInfo.StartInfo.RedirectStandardError = $true
  $pInfo.StartInfo.StandardErrorEncoding = [Text.Encoding]::UTF8
  $pInfo.Start()
  $pInfo.WaitForExit()
  $stdout = $pInfo.StandardOutput.ReadToEnd()
  $stderr = $pInfo.StandardError.ReadToEnd()
  Write-Host $stdout
  Write-Host $stderr
----

=== Filesystem

==== Path

* Combine a path with a child path
+
[source,powershell]
----
Join-Path $env:TEMP -ChildPath foo.txt
----

* https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/join-path?view=powershell-7.2[Join-Path (Microsoft.PowerShell.Management) - PowerShell | Microsoft Docs^]

==== Create/Remove Directory

* Create a directory
+
[source,powershell]
----
New-Item -ItemType Directory foo
----
+
* Remove a directory
+
[source,powershell]
----
Remove-Item -Path foo
----

==== Rename/Move file

* Rename single file

** Using `Rename-Item`
+
[source,powershell]
----
$sourceDir = "C:\path to dir"
New-Item -path (Join-Path $sourceDir "apple - a1.txt")
Rename-Item (Join-Path $sourceDir "apple - a1.txt") -NewName "apple - a01.txt"
Remove-Item (Join-Path $sourceDir "apple - a01.txt")
----

** Using `Move-Item`
+
[source,powershell]
----
$sourceDir = "C:\path to dir"
$file1 = New-Item -path (Join-Path $sourceDir "apple - a1.txt")
Move-Item (Join-Path $sourceDir "apple - a1.txt") (Join-Path $sourceDir "apple - a01.txt")
Remove-Item (Join-Path $sourceDir "apple - a01.txt")
----

** Using `Rename-Item` with pipe
+
[source,powershell]
----
$sourceDir = "C:\path to dir"
$file1 = New-Item -path (Join-Path $sourceDir "apple - a1.txt")
$file1 | Rename-Item -NewName "apple - a01.txt"
Remove-Item (Join-Path $sourceDir "apple - a01.txt")
----

** Using `Move-Item` with pipe
+
[source,powershell]
----
$sourceDir = "C:\path to dir"
$file1 = New-Item -path (Join-Path $sourceDir "apple - a1.txt")
$file1 | Move-Item -Destination (Join-Path $sourceDir "apple - a01.txt")
Remove-Item (Join-Path $sourceDir "apple - a01.txt")
----

** Using `MoveTo`
+
[source,powershell]
----
$sourceDir = "C:\path to dir"
$file1 = New-Item -path (Join-Path $sourceDir "apple - a1.txt")
$file1.MoveTo((Join-Path $file1.Directory "apple - a01.txt"))
Remove-Item (Join-Path $sourceDir "apple - a01.txt")
----

* Rename multiple files
+
[source,powershell]
----
include::../src/fs/RenameFiles.ps1[tag=rename-files]
----
+
[subs="quotes"]
.Results
----
... Before
Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----        2022/10/16     12:30              0 apple - *n1*.txt
-a----        2022/10/16     12:30              0 apple - *n2*.txt
-a----        2022/10/16     12:30              0 apple - *n3*.txt
-a----        2022/10/16     12:30              0 banana - n1.txt
-a----        2022/10/16     12:30              0 banana - n2.txt
-a----        2022/10/16     12:30              0 banana - n3.txt
INFO: Rename succeeded.

... After

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----        2022/10/16     12:30              0 apple - *n01*.txt
-a----        2022/10/16     12:30              0 apple - *n02*.txt
-a----        2022/10/16     12:30              0 apple - *n03*.txt
-a----        2022/10/16     12:30              0 banana - n1.txt
-a----        2022/10/16     12:30              0 banana - n2.txt
-a----        2022/10/16     12:30              0 banana - n3.txt
----

.References
* https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/rename-item?view=powershell-5.1#outputs[Rename-Item (Microsoft.PowerShell.Management) - PowerShell | Microsoft Learn^]
* https://learn.microsoft.com/ja-jp/powershell/module/microsoft.powershell.management/move-item?view=powershell-5.1[Move-Item (Microsoft.PowerShell.Management) - PowerShell | Microsoft Learn^]

==== Create/Remove/Copy File

* Create a new file
+
[source,powershell]
----
New-Item -ItemType File -Path foo.txt
----

* Remove a file
+
[source,powershell]
----
Remove-Item -Path foo.txt
----

** Delete file if exists
+
[source,powershell]
----
$FileName = "D:\PowerShell\ZeroFileSize.txt"
if (Test-Path $FileName) {
  Remove-Item -Force $FileName
}
----

[source,powershell]
----
New-Item -ItemType File -Path (Join-Path $env:TEMP -ChildPath foo.txt)
Remove-Item -Path (Join-Path $env:TEMP -ChildPath foo.txt)
----

==== Copy files

* Copy a file
+
[source,powershell]
----
Copy-Item "C:\foo.txt" -Destination "C:\Temp\"
----

.References
* https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/copy-item?view=powershell-7.2[Copy-Item (Microsoft.PowerShell.Management) - PowerShell | Microsoft Docs^]

==== Archive

[source,powershell]
----
Compress-Archive memo.txt -DestinationPath out.zip
Compress-Archive memo.txt -DestinationPath out.zip -Update -CompressionLevel NoCompression
Compress-Archive memo.txt -DestinationPath out.zip -Update -CompressionLevel Optimal
Compress-Archive memo.txt -DestinationPath out.zip -Update -CompressionLevel Fastest
----

[source,console]
----
> [io.compression.ZipFile]::OpenRead(".\Downloads\out.zip").entries | ? { $_.FullName -match "^[^/]+/*$"} | ft -a FullName,LastWriteTime
FullName LastWriteTime
-------- -------------
memo.txt 2020/12/26 14:11:28 +09:00
----

.References
* https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.archive/compress-archive?view=powershell-7.2[Compress-Archive (Microsoft.PowerShell.Archive) - PowerShell | Microsoft Docs^] +
  Compress-Archive - Google 検索
* https://docs.microsoft.com/ja-jp/dotnet/api/system.io.compression.zipfile.openread?view=net-6.0[ZipFile.OpenRead(String) メソッド (System.IO.Compression) | Microsoft Docs^]

=== Hdd

==== Show disk information

* Gets a list of all PhysicalDisk objects
+
[source,powershell]
----
Get-PhysicalDisk
----
+
[source,powershell]
.Show member
----
Get-PhysicalDisk | Get-Member
----

* Gets one or more disks visible to the operating system.
+
[source,powershell]
----
Get-Disk
----
+
[source,powershell]
.Show member
----
Get-Disk | Get-Member
----

.References
* https://docs.microsoft.com/en-us/powershell/module/storage/get-physicaldisk?view=windowsserver2019-ps[Get-PhysicalDisk (Storage) | Microsoft Docs^]
* https://docs.microsoft.com/en-us/powershell/module/storage/get-disk?view=windowsserver2019-ps[Get-Disk (Storage) | Microsoft Docs^]

==== Get all RAW disks, initialize the disks, partition, and format them

. Check disk number column and Partition Style column is `Raw`.
+
[source,console]
----
PS C:\> Get-Disk
----

. Start powershell with the Run as Administrator

. Initialize the disks, partition, and format them
+
[source,powershell]
----
Get-Disk | Where-Object PartitionStyle -Eq "RAW" | Initialize-Disk -PartitionStyle GPT -PassThru | New-Partition -DriveLetter H -UseMaximumSize | Format-Volume -NewFileSystemLabel 'backup'
----

==== Initialize disk step by step

. Check disk number
+
[source,console]
----
PS C:\> Get-Disk
----

. Start powershell with the Run as Administrator

. Initialize a disk on disk _2_ using the GPT partition
+
[source,powershell]
----
Initialize-Disk -Number 2 -PartitionStyle GPT
----
+
.References
* https://docs.microsoft.com/en-us/powershell/module/storage/initialize-disk?view=windowsserver2019-ps[Initialize-Disk (Storage) | Microsoft Docs^]

. Create a new partition on disk 2
+
[source,powershell]
----
New-Partition -DiskNumber 2 -DriveLetter H
----
+
.References
* https://docs.microsoft.com/en-us/powershell/module/storage/new-partition?view=windowsserver2019-ps[New-Partition (Storage) | Microsoft Docs^]

. Quick format `H` drives
+
[source,powershell]
----
New-Partition -DiskNumber 2 -DriveLetter H -NewFileSystemLabel 'backup'
----
+
.References
* https://docs.microsoft.com/en-us/powershell/module/storage/format-volume?view=windowsserver2019-ps[Format-Volume (Storage) | Microsoft Docs^]

==== How to convert my hard disk PartitionStyle from GPT back to RAW in Windows 10

[source,powershell]
----
Clear-Disk -Number 2
----

.References
* https://docs.microsoft.com/en-us/powershell/module/storage/clear-disk?view=windowsserver2019-ps[Clear-Disk (Storage) | Microsoft Docs^]

=== Windows

==== Windows Registry

* Get property
+
[source,powershell]
----
Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\Android Studio'
----

* Get-ChildItem
+
[source,powershell]
----
Get-ChildItem -Path 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall'
----

* Remove registry Key using `Remove-Item`
+
[source,powershell]
----
Remove-Item
----

* Check reboot pending
+
[source,powershell]
----
Test-Path 'HKLM:SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired'
Test-Path 'HKLM\Software\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending'
----

==== WSL

* Get IP in WSL
+
[source,powershell]
----
(bash.exe -c "hostname -I").Split(" ")[0]
----

* Invoke web request
+
[source,powershell]
----
Invoke-WebRequest http://localhost:8080/hello
Invoke-WebRequest http://$((bash.exe -c "hostname -I").Split(" ")[0]):8080/hello
----

* Get WSL Interface
+
[source,powershell]
----
Get-NetIPInterface | Where-Object {$_.InterfaceAlias -eq 'vEthernet (WSL)' -and $_.AddressFamily -eq 'IPv4'}
----

==== Profile

. Get profile path
+
[source,powershell]
----
$PROFILE | Get-Member -Type NoteProperty | Format-Table -Wrap
----
+
----
%HOMEPATH%\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1
----

==== Turn off the beep

* Windows
+
[source,powershell]
----
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser
if (!(Test-Path -Path "$Profile")) {New-Item -ItemType File -Path "$Profile" -Force}
Add-Content -Value "Set-PSReadlineOption -BellStyle None" -Path "$Profile"
----

* Linux
+
[source,powershell]
----
if (!(Test-Path -Path "$Profile")) {New-Item -ItemType File -Path "$Profile" -Force}
Add-Content -Value "Set-PSReadlineOption -BellStyle None" -Path "$Profile"
----

=== Testing

* pwsh
+
[source,powershell]
----
Install-Module -Name Pester -Force -SkipPublisherCheck
----

* Windows 10
+
[source,powershell]
----
$module = "C:\Program Files\WindowsPowerShell\Modules\Pester"
takeown /F $module /A /R
icacls $module /reset
icacls $module /grant "*S-1-5-32-544:F" /inheritance:d /T
Remove-Item -Path $module -Recurse -Force -Confirm:$false

Install-Module -Name Pester -Force
----

.References
* https://pester.dev/docs/introduction/installation[Installation and Update | Pester^]
